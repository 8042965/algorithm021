## æœ¬å‘¨ä½œä¸š

### ç®€å•ï¼š

- ç”¨ add first æˆ– add last è¿™å¥—æ–°çš„ API æ”¹å†™ Deque çš„ä»£ç 
- åˆ†æ Queue å’Œ Priority Queue çš„æºç 
- [åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)ï¼ˆFacebookã€å­—èŠ‚è·³åŠ¨ã€å¾®è½¯åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰
- [æ—‹è½¬æ•°ç»„](https://leetcode-cn.com/problems/rotate-array/)ï¼ˆå¾®è½¯ã€äºšé©¬é€Šã€PayPal åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰
- [åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰
- [åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)ï¼ˆFacebook åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰
- [ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨ã€è°·æ­Œã€Facebookã€è‹¹æœã€å¾®è½¯åœ¨åŠå¹´å†…é¢è¯•ä¸­é«˜é¢‘å¸¸è€ƒï¼‰
- [ç§»åŠ¨é›¶](https://leetcode-cn.com/problems/move-zeroes/)ï¼ˆFacebookã€äºšé©¬é€Šã€è‹¹æœåœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰
- [åŠ ä¸€](https://leetcode-cn.com/problems/plus-one/)ï¼ˆè°·æ­Œã€å­—èŠ‚è·³åŠ¨ã€Facebook åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰

### ä¸­ç­‰ï¼š

- [è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—](https://leetcode.com/problems/design-circular-deque)ï¼ˆFacebook åœ¨ 1 å¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰

### å›°éš¾ï¼š

- [æ¥é›¨æ°´](https://leetcode.com/problems/trapping-rain-water/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨ã€é«˜ç››é›†å›¢ã€Facebook åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰

## ä¸‹å‘¨é¢„ä¹ 

### é¢„ä¹ é¢˜ç›®ï¼š

- [æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](https://leetcode-cn.com/problems/valid-anagram/description/)
- [äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
- [æœ€å°çš„ k ä¸ªæ•°](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)







## æœ¬å‘¨ä½œä¸šæäº¤å†…å®¹

### ç®€å•ï¼š

#### 1ã€ã€Ã—ã€‘ç”¨ add first æˆ– add last è¿™å¥—æ–°çš„ API æ”¹å†™ Deque çš„ä»£ç 

**æ—¶é—´ä¸å¤ªå¤Ÿï¼Œå¾…è¡¥**

#### 2ã€ã€Ã—ã€‘åˆ†æ Queue å’Œ Priority Queue çš„æºç 

**æ—¶é—´ä¸å¤ªå¤Ÿï¼Œå¾…è¡¥**

#### 3ã€ã€âˆšã€‘[åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)ï¼ˆFacebookã€å­—èŠ‚è·³åŠ¨ã€å¾®è½¯åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰



**è‡ªå·±****åšçš„ï¼š**

> å¯ä»¥çœ‹åˆ°é¢˜ç›®ä¸­æåˆ°äº†ç»™å‡ºçš„æ•°ç»„æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥é‡å¤çš„æ•°æ®ä¸€å®šæ˜¯æŒ¨ç€çš„ï¼Œæ‰€ä»¥å¯ä»¥é¡ºåºæŸ¥æ‰¾ï¼Œé‚£ä¹ˆå°±éœ€è¦éå†
>
> æ•´ä¸ªæ•°ç»„ä»¥æ­¤è¾¾åˆ°ç›®çš„ã€‚
>
> åœ¨éå†çš„è¿‡ç¨‹ä¸­ä½¿ç”¨ä¸€ä¸ªä¸€ä¸ªæŒ‡é’ˆå§‹ç»ˆè®°å½•ç€å‰ä¸€ä¸ªä¸æ˜¯é‡å¤çš„ä½ç½®ã€‚
>
> ä»¥æ­¤éå†ã€‚
>
> å¦‚æœä¸N+1ä¸ªä½ç½®éƒ½æ˜¯é‡å¤çš„é‚£ä¹ˆå°±è·³è¿‡ï¼Œç»§ç»­å¯»æ‰¾ä¸‹ä¸€ä¸ªä¸æ˜¯é‡å¤çš„ä½ç½®ï¼Œå¹¶æŠŠæ­¤æ•°æ®è®°å½•åœ¨å‰ä¸€ä¸ªä¸æ˜¯é‡å¤ä½ç½®çš„åé¢å³å¯ã€‚
>
> æœ€ç»ˆè¿”å›ä¸æ˜¯é‡å¤ä½ç½®çš„æŒ‡é’ˆ+1å³æ˜¯è¿™ä¸ªèŒƒå›´ã€‚
>
> 
>
> ä¹Ÿæ˜¯åŒæŒ‡é’ˆï¼Œä½†æ˜¯ä¸å¦‚åˆ«äººçš„ç®€æ´



```java
    public int removeDuplicates(int[] nums) {
        int oldLen = nums.length;

        int newIndex = 0; //å‰ä¸€ä¸ª
        for (int i = 1; i < oldLen; i++) {
            //å¦‚æœå‰ä¸€ä¸ªç­‰äºåä¸€ä¸ªæ•°ï¼Œå°±
            while (nums[newIndex] == nums[i]){
                i++;

                //å¦‚æœiåˆ°å¤´äº†ï¼Œè¯´æ˜æ•´ä¸ªæ•°ç»„éƒ½æ˜¯é‡å¤çš„ï¼Œå°±è¿”å›1å³å¯
                if(i==oldLen){
                    return ++newIndex;
                }
            }

            //èµ°åˆ°è¿™ï¼Œè¯´æ˜nums[j] != nums[i]
            nums[++newIndex]=nums[i];
        }

        //æœ€ç»ˆçš„ç´¢å¼•é•¿åº¦+1å°±æ˜¯éœ€è¦çš„èŒƒå›´
        return ++newIndex;
    }
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1101539/1606832314962-4ffe6a75-c8ee-496b-83a3-b275d6d37f1e.png)



çœ‹åˆ°ä¸€ä¸ªèµåŒæ•°æ¯”è¾ƒé«˜çš„ï¼š

```java
 static public int removeDuplicates2(int[] nums) {

       if(nums==null || nums.length == 0) return 0;

       int oldLen = nums.length;

       int i = 0;//å§‹ç»ˆæŒ‡å®šç€å‰ä¸€ä¸ªä¸æ˜¯é‡å¤çš„ä½ç½®
       int j = 1;//ä¸€ç›´å‘åèµ°ï¼Œæ‰¾åˆ°ä¸æ˜¯é‡å¤çš„ä½ç½®

       while (j < oldLen){

           //å¦‚æœä¸ç›¸ç­‰
           if(nums[i] != nums[j]){
               nums[i+1] = nums[j];
               i++;
           }
           j++;
       }

       return i+1;

    }
```





#### 4ã€ã€âˆšã€‘[æ—‹è½¬æ•°ç»„](https://leetcode-cn.com/problems/rotate-array/)ï¼ˆå¾®è½¯ã€äºšé©¬é€Šã€PayPal åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰



è‡ªå·±å†™çš„ï¼š



```java
    public void rotate(int[] nums, int k) {
        int len = nums.length-1;

        //ä»ç¬¬kä¸ªå¼€å§‹æ—‹è½¬,å¦‚æœk=3ï¼Œè¯´æ˜è¦å¾ªç¯3æ¬¡
        for (int i = k ; i > 0 ; i--) {
            //ä¸´æ—¶è®°å½•ä¸‹æ¥éœ€è¦æåˆ°å‰é¢çš„æ•°å­—
            int temp = nums[len];

            //å‘åæŒªåŠ¨ï¼Œä»ç¬¬1ä¸ªä½ç½®å¼€å§‹å¾€åæŒªåŠ¨
            for (int j = len-1 ; j >= 0 ; j--) {
                nums[j+1] = nums[j];
            }
            nums[0] = temp;
        }
    }
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1101539/1606836279744-4cc07fe5-07a8-40d5-a77b-55c6ae9d3994.png)



è™½ç„¶æˆåŠŸäº†ï¼Œä½†æ˜¯è€—æ—¶æ—¶é—´å¤æ‚åº¦å¤ªé«˜



æ—¶é—´å¤æ‚åº¦è¾¾åˆ°äº†O(kn)çº§







#### 5ã€ã€âˆšã€‘[åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        
        if(l1==null){
            return l2;
        } 

        if(l2==null){
            return l1;
        }

        int v1 = l1.val;
        int v2 = l2.val;
        
        if(v1<v2){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }

    }
}
```



#### 6ã€ã€âˆšã€‘[åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)ï¼ˆFacebook åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰



```java
//ç»™ä½ ä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œè¯·ä½ å°† nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿ nums1 æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚ 
//
// 
//
// è¯´æ˜ï¼š 
//
// 
// åˆå§‹åŒ– nums1 å’Œ nums2 çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º m å’Œ n ã€‚ 
// ä½ å¯ä»¥å‡è®¾ nums1 æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆç©ºé—´å¤§å°å¤§äºæˆ–ç­‰äº m + nï¼‰æ¥ä¿å­˜ nums2 ä¸­çš„å…ƒç´ ã€‚ 
// 
//
// 
//
// ç¤ºä¾‹ï¼š 
//
// 
//è¾“å…¥ï¼š
//nums1 = [1,2,3,0,0,0], m = 3
//nums2 = [2,5,6],       n = 3
//
//è¾“å‡ºï¼š[1,2,2,3,5,6] 
//
// 
//
// æç¤ºï¼š 
//
// 
// -10^9 <= nums1[i], nums2[i] <= 10^9 
// nums1.length == m + n 
// nums2.length == n 
// 
// Related Topics æ•°ç»„ åŒæŒ‡é’ˆ 
// ğŸ‘ 704 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (m == 0) {
            nums1[0] = nums2[0];
        }
        m--;
        n--;

        while (m >= 0 && n >= 0) {
            if (nums1[m] > nums2[n]) {
                nums1[m + n + 1] = nums1[m];
                m--;
            } else {
                nums1[m + n + 1] = nums2[n];
                n--;
            }
        }

        int index = m + n + 1;
        if (m == -1 && n >= 0) {
            while (n >= 0) {
                nums1[index--] = nums2[n--];
            }
        }

        if (m >= 0 && n == -1) {
            while (m >= 0)
                nums1[index--] = nums1[m--];
        }
    }
}
//leetcode submit region end(Prohibit modification and deletion)
```



#### 7ã€ã€âˆšã€‘[ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨ã€è°·æ­Œã€Facebookã€è‹¹æœã€å¾®è½¯åœ¨åŠå¹´å†…é¢è¯•ä¸­é«˜é¢‘å¸¸è€ƒï¼‰

```java
package ç®—æ³•è®­ç»ƒè¥.ç¬¬ä¸€å‘¨.ç»ƒä¹ ;

import java.util.Arrays;

public class ä¸¤æ•°ä¹‹å’Œ {
    static public int[] twoSum(int[] nums, int target) {


        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i+1; j < nums.length ; j++) {
                if(nums[i] + nums[j] == target){
                    return new int[]{i,j};
                }
            }
        }

        return new int[]{};
    }

    public static void main(String[] args) {
        int [] nums = {3,3};
        int target = 6;

        int[] ints = twoSum(nums, target);
        System.out.println(Arrays.toString(ints));
    }
}
```



#### 8ã€ã€âˆšã€‘[ç§»åŠ¨é›¶](https://leetcode-cn.com/problems/move-zeroes/)ï¼ˆFacebookã€äºšé©¬é€Šã€è‹¹æœåœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰



```java
package ç®—æ³•è®­ç»ƒè¥;

public class moveZeroes {
    static public void moveZeroes(int[] nums) {
        int j = 0;

        for (int i = 0; i < nums.length; i++) {
            //å¦‚æœé‡åˆ°çš„æ•°æ®ä¸º0ï¼Œå°±æŠŠåé¢çš„å¾€å‰ç§»åŠ¨ã€‚ä¾‹å¦‚ï¼š[0,1,0,3,12] -> [1,0,3,12,0]
            if(nums[i]!=0){
                //å‘å‰ç§»åŠ¨
                nums[j] = nums[i];
                if(i != j){
                    nums[i] = 0;
                }
                j++;
            }
        }
    }

    static public int maxArea(int[] height) {

        int max = 0;

        for(int i = 0; i < height.length -1 ; i++){
            for(int j = i + 1 ; j < height.length; j++){
                int area = ( j - i) * Math.min(height[i],height[j]);
                max = Math.max(area,max);
            }
        }

        return max;
    }

    public static void main(String[] args) {

//        int[] array = {4,3,2,1,4};
//        System.out.println(maxArea(array));
        int [] ints = {0,1,0,3,12};
//        int [] ints = {0,0,1};
        moveZeroes(ints);

        for (int anInt : ints) {
            System.out.print(anInt+",");
        }

    }
}
```





#### 9ã€ã€âˆšã€‘[åŠ ä¸€](https://leetcode-cn.com/problems/plus-one/)ï¼ˆè°·æ­Œã€å­—èŠ‚è·³åŠ¨ã€Facebook åœ¨åŠå¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰





```java
package ç®—æ³•è®­ç»ƒè¥.ç¬¬ä¸€å‘¨.ç»ƒä¹ ;

import java.util.Arrays;

public class åŠ ä¸€ {

   static public int[] plusOne(int[] digits) {

        for (int i = digits.length-1; i >= 0; i--) {
            //ä»å°¾éƒ¨å¼€å§‹+1
            digits[i]++;

            digits[i] %= 10;

            //å¦‚æœæ¨¡10ä¹‹åä¸ç­‰äº0ï¼Œè¯´æ˜ä¸éœ€è¦è¿›ä½äº†ï¼Œå°±ç›´æ¥è¿”å›ç°åœ¨çš„æ•°ç»„æå®¢
            if(digits[i]  != 0)
                return digits;
        }

        //è¯´æ˜[9,0,0]å‡ºç°è¿™ç§æƒ…å†µäº†ï¼Œç¬¬1ä¸ªæ•°ä¸º9
        int newIntArray[] = new int[digits.length+1];
        newIntArray[0]=1;

        return newIntArray;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(plusOne(new int[]{9,9})));
    }
}
```



### ä¸­ç­‰ï¼š

#### 1ã€[è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—](https://leetcode.com/problems/design-circular-deque)ï¼ˆFacebook åœ¨ 1 å¹´å†…é¢è¯•ä¸­è€ƒè¿‡ï¼‰



è‡ªå·±åšäº†å¥½ä¹…ï¼Œéƒ½ä¸å¤ªè¡Œï¼Œè€Œä¸”è®¾è®¡çš„è¿˜æ¯”è¾ƒå¤æ‚ï¼š

```java
package ç®—æ³•è®­ç»ƒè¥.ç¬¬ä¸€å‘¨.ç»ƒä¹ ;

import java.util.Arrays;

public class è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ— {
    public static void main(String[] args) {
        MyCircularDeque myCircularDeque = new MyCircularDeque(3);

        boolean b = myCircularDeque.insertLast(1);
        boolean b1 = myCircularDeque.insertLast(2);
        boolean b2 = myCircularDeque.insertFront(3);
        boolean b3 = myCircularDeque.insertFront(4);
        int rear = myCircularDeque.getRear();
        boolean full = myCircularDeque.isFull();
        boolean b4 = myCircularDeque.deleteLast();
        boolean b5 = myCircularDeque.insertFront(4);
        int front = myCircularDeque.getFront();
        System.out.println(b);

    }
}

class MyCircularDeque {

    static int[] data = null;
    static int len = 0;
    static int add_len = 0;//æ’å…¥çš„æ•°æ®è®¡æ•°å™¨

    static int fornt_index = 0;//è®°å½•å‰é¢æ’å…¥çš„ä½ç½®
    static int last_index = 0;//è®°å½•åé¢æ’å…¥çš„ä½ç½®

    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        data = new int[k];
        Arrays.fill(data,-1);
        len = k;
        last_index = k-1;
    }

    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {

        if(add_len >= len ){
            return false;
        }else{

            //1ã€æŒªåŠ¨ä½ç½®(å‘å)
            for (int i = fornt_index+1; i > 0 ; i--) {
                data[i+1] = data[i];
                fornt_index--;
                data[i]=-1;
            }
//            for (int i = fornt_index ; i < last_index-1 ; i++) {
//                System.out.println("--->"+data[i]);
//                data[i+1] = data[i];
//                fornt_index--;
//                data[i]=-1;
//            }

            //2ã€æŠŠæ•°æ®å†™å…¥ç¬¬ä¸€ä¸ªä½ç½®
            data[0] = value;

            fornt_index++;

            add_len++;//è®¡æ•°

            return true;
        }
    }

    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        //1ã€æŠŠæ•°æ®å†™å…¥æœ€åä¸€ä¸ªä½ç½®
        try {
            
            //1ã€æŒªåŠ¨ä½ç½®
            if(last_index < len-1){
                for (int i = len-1  ; i > last_index; i--) {
                    System.out.println("--->"+data[i]);
                    data[i-1] = data[i];
                    last_index++;
                    data[i]=-1;
                }
            }

            data[last_index--] = value;
            add_len++;//è®¡æ•°

            return true;
        }catch (Exception e){
            return false;
        }
    }

    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        try {
            //1ã€ä»ç¬¬1ä¸ªä½ç½® å‘å‰æŒª
            for (int i = 0 ; i < len - 1  ; i++) {
                data[i] = data[i+1];
            }

            //2ã€æ•°é‡-1
            add_len--;
            return true;
        }catch (Exception e){
            return false;
        }
    }

    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        try {
            //1ã€ä»ç¬¬last_indexä¸ªä½ç½® å‘å‰æŒª
            for (int i = last_index ; i < len - 1  ; i++) {
                data[i+1] = data[i];
            }

            //æ¢å¤-1
            data[last_index] = -1;

            last_index--;
            add_len--;

            return true;
        }catch (Exception e){
            return false;
        }
    }

    /** Get the front item from the deque. */
    public int getFront() {
        return fornt_index==0 ? -1 : data[0];
    }

    /** Get the last item from the deque. */
    public int getRear() {
        return data[len-1];
    }

    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return add_len==0;
    }

    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return add_len==len;
    }
}
```



å­¦ä¹ çš„æ¯”è¾ƒç»å…¸çš„ä¸€ä¸ªï¼š



https://leetcode-cn.com/problems/design-circular-deque/solution/shu-zu-shi-xian-de-xun-huan-shuang-duan-dui-lie-by/



```java
//è®¾è®¡å®ç°åŒç«¯é˜Ÿåˆ—ã€‚ 
//ä½ çš„å®ç°éœ€è¦æ”¯æŒä»¥ä¸‹æ“ä½œï¼š 
//
// 
// MyCircularDeque(k)ï¼šæ„é€ å‡½æ•°,åŒç«¯é˜Ÿåˆ—çš„å¤§å°ä¸ºkã€‚ 
// insertFront()ï¼šå°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åŒç«¯é˜Ÿåˆ—å¤´éƒ¨ã€‚ å¦‚æœæ“ä½œæˆåŠŸè¿”å› trueã€‚ 
// insertLast()ï¼šå°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åŒç«¯é˜Ÿåˆ—å°¾éƒ¨ã€‚å¦‚æœæ“ä½œæˆåŠŸè¿”å› trueã€‚ 
// deleteFront()ï¼šä»åŒç«¯é˜Ÿåˆ—å¤´éƒ¨åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚ å¦‚æœæ“ä½œæˆåŠŸè¿”å› trueã€‚ 
// deleteLast()ï¼šä»åŒç«¯é˜Ÿåˆ—å°¾éƒ¨åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœæ“ä½œæˆåŠŸè¿”å› trueã€‚ 
// getFront()ï¼šä»åŒç«¯é˜Ÿåˆ—å¤´éƒ¨è·å¾—ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœåŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› -1ã€‚ 
// getRear()ï¼šè·å¾—åŒç«¯é˜Ÿåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ å¦‚æœåŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› -1ã€‚ 
// isEmpty()ï¼šæ£€æŸ¥åŒç«¯é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚ 
// isFull()ï¼šæ£€æŸ¥åŒç«¯é˜Ÿåˆ—æ˜¯å¦æ»¡äº†ã€‚ 
// 
//
// ç¤ºä¾‹ï¼š 
//
// MyCircularDeque circularDeque = new MycircularDeque(3); // è®¾ç½®å®¹é‡å¤§å°ä¸º3
//circularDeque.insertLast(1);                  // è¿”å› true
//circularDeque.insertLast(2);                  // è¿”å› true
//circularDeque.insertFront(3);                 // è¿”å› true
//circularDeque.insertFront(4);                 // å·²ç»æ»¡äº†ï¼Œè¿”å› false
//circularDeque.getRear();                  // è¿”å› 2
//circularDeque.isFull();                       // è¿”å› true
//circularDeque.deleteLast();                   // è¿”å› true
//circularDeque.insertFront(4);                 // è¿”å› true
//circularDeque.getFront();             // è¿”å› 4
//  
//
// 
//
// æç¤ºï¼š 
//
// 
// æ‰€æœ‰å€¼çš„èŒƒå›´ä¸º [1, 1000] 
// æ“ä½œæ¬¡æ•°çš„èŒƒå›´ä¸º [1, 1000] 
// è¯·ä¸è¦ä½¿ç”¨å†…ç½®çš„åŒç«¯é˜Ÿåˆ—åº“ã€‚ 
// 
// Related Topics è®¾è®¡ é˜Ÿåˆ— 
// ğŸ‘ 65 ğŸ‘ 0


import java.util.Arrays;

//leetcode submit region begin(Prohibit modification and deletion)
class MyCircularDeque {


    private int capacity;
    private int [] arr;
    private int front;
    private int rear;


    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        capacity = k +1;
        arr = new int[capacity];
        front = 0;
        rear = 0;
    }

    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if(isFull()){
            return false;
        }

        front = (front -1 + capacity) % capacity;
        arr[front] = value;
        return true;
    }

    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if (isFull()) {
            return false;
        }

        arr[rear] = value;

        rear = (rear +1) %capacity;
        return true;
    }

    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if (isEmpty()) {
            return false;
        }

        front = (front+1) % capacity;
        return true;
    }

    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if (isEmpty()) {
            return false;
        }
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }

    /** Get the front item from the deque. */
    public int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }

    /** Get the last item from the deque. */
    public int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return arr[(rear - 1 + capacity) % capacity];
    }

    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return front == rear;
    }

    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return (rear + 1) % capacity == front;
    }
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque obj = new MyCircularDeque(k);
 * boolean param_1 = obj.insertFront(value);
 * boolean param_2 = obj.insertLast(value);
 * boolean param_3 = obj.deleteFront();
 * boolean param_4 = obj.deleteLast();
 * int param_5 = obj.getFront();
 * int param_6 = obj.getRear();
 * boolean param_7 = obj.isEmpty();
 * boolean param_8 = obj.isFull();
 */
//leetcode submit region end(Prohibit modification and deletion)
```



### å›°éš¾ï¼š

#### 1ã€[æ¥é›¨æ°´](https://leetcode.com/problems/trapping-rain-water/)ï¼ˆäºšé©¬é€Šã€å­—èŠ‚è·³åŠ¨ã€é«˜ç››é›†å›¢ã€Facebook åœ¨åŠå¹´å†…é¢è¯•å¸¸è€ƒï¼‰